; Kira Native Code - x86-64 with ARC
; Generated by Kira Compiler

global main
extern printf
extern malloc
extern free

section .data
    fmt_int: db "%d", 10, 0
    fmt_obj: db "<object@%p>", 10, 0

section .text

    ; ARC Retain - increment reference count
kira_retain:
    push rbp
    mov rbp, rsp
    test rdi, rdi           ; Check for null
    jz .retain_null
    mov eax, [rdi]          ; Load refCount
    inc eax                 ; Increment
    mov [rdi], eax          ; Store back
.retain_null:
    pop rbp
    ret

    ; ARC Release - decrement reference count and free if zero
kira_release:
    push rbp
    mov rbp, rsp
    test rdi, rdi           ; Check for null
    jz .release_null
    mov eax, [rdi]          ; Load refCount
    dec eax                 ; Decrement
    mov [rdi], eax          ; Store back
    test eax, eax           ; Check if zero
    jnz .release_null
    ; refCount is 0, free the object
    call free               ; Free memory
.release_null:
    pop rbp
    ret

    ; ARC Allocate - allocate object with header
kira_allocate:
    push rbp
    mov rbp, rsp
    ; rdi = size, rsi = typeId
    add rdi, 16             ; Add header size
    call malloc
    test rax, rax
    jz .alloc_failed
    mov dword [rax], 1      ; Set refCount = 1
    mov dword [rax+4], esi  ; Set typeId
    mov dword [rax+8], edi  ; Set size
    mov dword [rax+12], 0   ; Set flags = 0
.alloc_failed:
    pop rbp
    ret

    ; 
fibonacci:
    push rbp
    mov rbp, rsp
    sub rsp, 8        ; Allocate locals
    mov [rbp-8], rdi    ; Store param 0
    push qword [rbp-8]
    push 1
    pop rbx
    pop rax
    cmp rax, rbx
    setl al              ; Set AL if less
    movzx rax, al
    push rax
    pop rax
    test rax, rax
    jnz .L0
    push qword [rbp-8]
    pop rax              ; Return value
    mov rsp, rbp
    pop rbp
    ret
.L0:
    push qword [rbp-8]
    push 1
    pop rbx
    pop rax
    sub rax, rbx
    push rax
    pop rdi              ; First argument
    call fibonacci
    push rax             ; Return value
    pop qword [rbp-16]
    push qword [rbp-8]
    push 2
    pop rbx
    pop rax
    sub rax, rbx
    push rax
    pop rdi              ; First argument
    call fibonacci
    push rax             ; Return value
    push qword [rbp-16]
    pop rbx
    pop rax
    add rax, rbx
    push rax
    pop rax              ; Return value
    mov rsp, rbp
    pop rbp
    ret
    mov rsp, rbp
    pop rbp
    ret

    ; 
main:
    push rbp
    mov rbp, rsp
    push 10
    pop rdi              ; First argument
    call fibonacci
    push rax             ; Return value
    pop rsi              ; Value to print
    mov rdi, fmt_int
    xor rax, rax
    call printf
    push 0
    pop rax              ; Return value
    mov rsp, rbp
    pop rbp
    ret
    mov rsp, rbp
    pop rbp
    ret


    ; End of program
