package net.exoad.kira.compiler.frontend.parser

import net.exoad.kira.compiler.analysis.diagnostics.Diagnostics
import net.exoad.kira.compiler.frontend.lexer.Token
import net.exoad.kira.compiler.frontend.parser.ast.ASTNode
import net.exoad.kira.compiler.frontend.parser.ast.RootASTNode
import net.exoad.kira.compiler.frontend.parser.ast.declarations.*
import net.exoad.kira.compiler.frontend.parser.ast.elements.*
import net.exoad.kira.compiler.frontend.parser.ast.expressions.*
import net.exoad.kira.compiler.frontend.parser.ast.literals.*
import net.exoad.kira.compiler.frontend.parser.ast.statements.*
import net.exoad.kira.core.IntrinsicRegistry
import net.exoad.kira.core.Keywords
import net.exoad.kira.source.SourceContext
import net.exoad.kira.source.SourcePosition
import net.exoad.kira.utils.EnglishUtils
import java.util.*
import kotlin.math.max
import kotlin.properties.Delegates

/**
 * A semi-naive LL(k) parser that strays from rollbacks as much as possible. It takes
 * the tokens generated by the [net.exoad.kira.compiler.frontend.lexer.KiraLexer] and uses those to turn them into an AST.
 *
 * It will then pass this AST onto the [net.exoad.kira.compiler.analysis.semantic.KiraSemanticAnalyzer] to make sure the AST is
 * valid grammar.
 */
class KiraParser(private val context: SourceContext) {
    private val buffer = TokenBuffer(context.tokens)

    init {
        context.astOrigins = IdentityHashMap()
        context.astIntrinsicMarked = IdentityHashMap()
    }

    fun <T : ASTNode> putOrigin(
        node: T,
        location: SourcePosition = here(),
    ): T // returns the original value to facilitate with easier refactoring
    {
        context.astOrigins[node] = location
        return node
    }

    fun here(): SourcePosition {
        return peek().canonicalLocation
    }

    /**
     * Star method to call on [KiraParser] that will turn the passed in [context] into an AST.
     */
    fun parse() {
        val statements = mutableListOf<Statement>()
        while (!at(Token.Type.S_EOF)) {
            statements.add(parseStatement(null))
        }
        if (statements.first().expr !is ModuleDecl) {
            Diagnostics.panic(
                "KiraParser::parse",
                "The first declaration of ${context.file} must be a module declaration!",
                context = context,
                location = SourcePosition(1, 1),
                selectorLength = max(1, context.findCanonicalLine(1).length)
            )
        }
        context.ast = RootASTNode(statements)
    }

    /**
     * Grabs the token at the [k]-th position (absolute).
     *
     * If you need relative positioning, take a look at [peek]
     */
    fun look(k: Int): Token {
        return buffer.peek(k - 1)
    }

    /**
     * Grabs the token [k] away from where the pointer is right now (relative).
     *
     * If you need absolute positioning, take a look at [look]
     *
     * - also performs caching on the result for the same relative
     */
    private fun peek(k: Int = 0): Token {
        return buffer.peek(k)
    }

    /**
     * Moves the pointer forward to the next token and thus "consumes" the current token
     */
    private fun advancePointer(count: Int = 1) {
        buffer.advance(count)
    }

    fun tryInOrder(candidates: Array<Array<Token.Type>>, peekOffset: Int = 0): Array<Token.Type>? {
        if (candidates.isEmpty()) {
            return null
        }
        if (candidates.size == 1) {
            val candidate = candidates[0]
            for (i in candidate.indices) {
                if (candidate[i] != peek(i + peekOffset).type) return null
            }
            return candidate
        }
        for (candidate in candidates) {
            var match = true
            for (i in candidate.indices) {
                if (candidate[i] != peek(i + peekOffset).type) {
                    match = false
                    break
                }
            }
            if (match) {
                return candidate
            }
        }
        return null
    }

    private inline fun expectOptionalThenAdvance(token: Token.Type, ifOk: () -> Unit = { advancePointer() }) {
        if (at(token)) {
            ifOk()
        }
    }

    private fun at(type: Token.Type): Boolean {
        return type == peek().type
    }

    private fun expectModifiers(modifier: Map<Modifier, SourcePosition>?, scopes: WrappingContext) {
        val r = if (modifier == null || modifier.isEmpty()) {
            null
        } else {
            modifier.keys.toList().find { !it.wrappingContext.contains(scopes) }
        }
        if (r != null) {
            Diagnostics.panic(
                "KiraParser::expectModifiers",
                buildString {
                    append("The modifier ")
                    append(r.tokenType.diagnosticsName())
                    append(" cannot be applied to a ")
                    append(WrappingContext.CLASS)
                },
                location = modifier?.get(r),
                // this is so sketchy lmao, going through the values of a map to find the key which is THE OPPOSITE THING A MAP IS FOR LMAO
                // but since the program is already crashing here, doesnt really matter
                //
                // it just feels really sketchy and could fail at anytime ig
                selectorLength = Keywords.reserved.filterValues { it == r.tokenType }.keys.first().length,
                context = context
            )
        }
    }

    private inline fun expectThenAdvance(
        token: Token.Type,
        noinline onBad: (() -> Nothing)? = null,
        ifOk: () -> Unit = { advancePointer() }
    ) {
        if (!at(token)) {
            if (onBad != null) {
                onBad()
            } else {
                val helpMessage = buildString {
                    when (token) {
                        Token.Type.S_OPEN_PARENTHESIS -> {
                            when (peek().type) {
                                Token.Type.S_OPEN_BRACE -> {
                                    append("Did you mean to use '(' instead of '{'? Function declarations require parentheses for parameters.")
                                }

                                Token.Type.S_COLON -> {
                                    append("Missing '(' before parameters. Function syntax is: fx name(params): ReturnType { ... }")
                                }

                                else -> {
                                    append("Insert '(' here to begin the parameter list or condition.")
                                }
                            }
                        }

                        Token.Type.S_CLOSE_PARENTHESIS -> {
                            append("Missing closing ')'. Check that all opening parentheses are properly closed.")
                        }

                        Token.Type.S_OPEN_BRACE -> {
                            append("Missing '{' to begin a block. Functions, classes, and control flow statements require braces around their body.")
                        }

                        Token.Type.S_CLOSE_BRACE -> {
                            append("Missing closing '}'. Check that all opening braces are properly closed.")
                        }

                        Token.Type.S_COLON -> {
                            if (peek().type == Token.Type.S_EQUAL) {
                                append("Use ':' for type annotations, not '='. Syntax: name: Type = value")
                            } else {
                                append("Missing ':' for type annotation. Variables and functions require type specifications.")
                            }
                        }

                        Token.Type.S_COMMA -> {
                            append("Missing ',' to separate elements. Use commas between list/map items, function parameters, or generic type arguments.")
                        }

                        Token.Type.S_SEMICOLON -> {
                            append("Missing ';' or newline to terminate the statement.")
                        }

                        Token.Type.S_EQUAL -> {
                            append("Missing '=' for assignment or initialization.")
                        }

                        Token.Type.IDENTIFIER -> {
                            if (peek().type == Token.Type.S_OPEN_PARENTHESIS) {
                                append("Expected an identifier (variable or function name) here, not '('. Did you forget the name?")
                            } else {
                                append("Expected an identifier (a name) here. Identifiers must start with a letter and use camelCase or PascalCase.")
                            }
                        }

                        Token.Type.S_OPEN_ANGLE -> {
                            append("Missing '<' to begin generic type parameters. Syntax: Type<T, U> or fx name<T>(params): ReturnType")
                        }

                        Token.Type.S_CLOSE_ANGLE -> {
                            append("Missing '>' to close generic type parameters. Check that all '<' are properly closed.")
                        }

                        else -> {
                            append("Insert '${token.diagnosticsName()}' here to fix the syntax error.")
                        }
                    }
                }

                Diagnostics.panic(
                    "KiraParser::expect",
                    buildString {
                        append("Expected ")
                        append(EnglishUtils.prependIndefiniteArticle(token.diagnosticsName().lowercase()))
                        append(" but got ")
                        append(EnglishUtils.prependIndefiniteArticle(peek().type.diagnosticsName()))
                        if (peek().type == Token.Type.IDENTIFIER || peek().type == Token.Type.L_STRING) {
                            append(" '${peek().content}'")
                        }
                        append("\n\nHelp: ")
                        append(helpMessage)
                    },
                    location = peek().canonicalLocation,
                    selectorLength = peek().content.length,
                    context = context
                )
            }
        } else {
            ifOk()
        }
    }

    private inline fun expectAnyOfThenAdvance(tokens: Array<Token.Type>, ifOk: () -> Unit = { advancePointer() }) {
        when {
            !tokens.contains(peek().type) ->
                Diagnostics.panic(
                    "KiraParser::expect",
                    buildString {
                        append("Expected any of ")
                        append(tokens.map { it.diagnosticsName() })
                        append(" but got ")
                        append(EnglishUtils.prependIndefiniteArticle(peek().type.diagnosticsName()))
                    },
                    location = peek().canonicalLocation,
                    context = context
                )

            else -> ifOk()
        }
    }

    fun parseStatement(modifier: Map<Modifier, SourcePosition>?): Statement {
        fun parseWithModifiers(): Statement {
            val baseLocation = here()
            val modifiers = parseModifiers()
            val expr = when (peek().type) {
                Token.Type.K_CLASS -> parseClassDecl(modifiers)
                Token.Type.K_ENUM -> parseEnumDecl(modifiers)
                Token.Type.K_ALIAS -> parseTypeAliasExpr(modifiers)
                Token.Type.K_VARIANT -> parseVariantDecl(modifiers)
                Token.Type.K_TRAIT -> parseTraitDecl(modifiers)
                else -> parsePrimaryExpr(modifiers)
            }
            expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
            return putOrigin(Statement(expr), baseLocation)
        }
        if (modifier != null && modifier.isNotEmpty()) {
            return parseWithModifiers()
        }
        // If keywords were lexed as simple identifiers (e.g., 'try' or 'throw'), handle them here too
        if (peek().type == Token.Type.IDENTIFIER) {
            val txt = peek().content
            if (txt == "throw") {
                return parseThrowStatement()
            }
            if (txt == "try") {
                return parseTryStatement()
            }
        }

        return when (peek().type) {
            // parse keywords stuffs first if possible (like keyword first statements)
            Token.Type.K_RETURN -> parseReturnStatement()
            Token.Type.K_IF -> parseIfSelectionStatement()
            Token.Type.K_WHILE -> parseWhileIterationStatement()
            Token.Type.K_DO -> parseDoWhileIterationStatement()
            Token.Type.K_FOR -> parseForIterationStatement()
            Token.Type.K_THROW -> parseThrowStatement()
            Token.Type.K_TRY -> parseTryStatement()
            Token.Type.K_USE -> parseUseStatement()
            Token.Type.K_BREAK -> parseBreakStatement()
            Token.Type.K_CONTINUE -> parseContinueStatement()
            in Token.Type.modifiers -> parseWithModifiers()
            Token.Type.K_CLASS -> // this part covers the case where the class decl has no modifiers on it. THIS CONDITION NEEDS TO BE UNDER THE PREVIOUS CONDITION
            {
                val baseLocation = here()
                val expr = parseClassDecl(null)
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                return putOrigin(Statement(expr), baseLocation)
            }

            Token.Type.K_TRAIT -> {
                val baseLocation = here()
                val expr = parseTraitDecl(null)
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                return putOrigin(Statement(expr), baseLocation)
            }

            Token.Type.K_ALIAS -> {
                val baseLocation = here()
                val expr = parseTypeAliasExpr(null)
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                return putOrigin(Statement(expr), baseLocation)
            }

            Token.Type.K_ENUM -> {
                val baseLocation = here()
                val expr = parseEnumDecl(null)
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                return putOrigin(Statement(expr), baseLocation)
            }

            Token.Type.K_VARIANT -> {
                val baseLocation = here()
                val expr = parseVariantDecl(null)
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                return putOrigin(Statement(expr), baseLocation)
            }

            else -> {
                val baseLocation = here()
                val expr = parseExpr()
                // todo: idk wtf this panic message is for ?
//                if(hereIs( Token.Type.L_INTEGER || hereIs( Token.Type.IDENTIFIER)
//                {
//                    Diagnostics.panic(
//                        "KiraParser::parseStatement",
//                        "Unexpected token '${peek().content}'",
//                        location = peek().canonicalLocation,
//                        selectorLength = peek().content.length,
//                        context = context
//                    )
//                }
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                return putOrigin(Statement(expr), baseLocation)
            }
        }
    }

    /**
     * Used to parse a statement between two `{}` AKA a block.
     */
    private fun parseStatementBlock(): List<Statement> {
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val statements = mutableListOf<Statement>()
        while (!at(Token.Type.S_CLOSE_BRACE) && !at(Token.Type.S_EOF)) {
            statements.add(parseStatement(null))
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACE)
        return statements
    }

    fun parseReturnStatement(): Statement // y dont they just call it a return expr? lol beats me tho, just another way to represent an astnode
    {
        val origin = here()
        expectThenAdvance(Token.Type.K_RETURN)
        val expr = parseExpr()
        expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
        return putOrigin(ReturnStatement(expr), origin)
    }

    fun parseBreakStatement(): Statement {
        val origin = here()
        expectThenAdvance(Token.Type.K_BREAK)
        return putOrigin(BreakStatement(), origin)
    }

    fun parseContinueStatement(): Statement {
        val origin = here()
        expectThenAdvance(Token.Type.K_CONTINUE)
        return putOrigin(ContinueStatement(), origin)
    }

    fun parseForIterationStatement(): Statement {
        val origin = here()
        expectThenAdvance(Token.Type.K_FOR)
        // support both: `for (mut x: expr) {}` and `for mut x: expr {}`
        val hasParens = at(Token.Type.S_OPEN_PARENTHESIS)
        if (hasParens) expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
        // todo: might need a better warning message here, since the initializer needs to be present
        expectThenAdvance(Token.Type.K_MODIFIER_MUTABLE)
        val identifier = parseIdentifier()
        expectThenAdvance(Token.Type.S_COLON)
        val target = parseExpr()
        if (hasParens) expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        val body = parseStatementBlock()
//        if (identifier !is Identifier) {
//            Diagnostics.panic(
//                "KiraParser::parseForIterationStatement",
//                "For iteration statements may only use identifiers.",
//                context = context,
//                location = context.astOrigins[identifier] ?: origin,
//            )
//        }
        return putOrigin(ForIterationStatement(ForIterationExpr(identifier, target, emptyList()), body), origin)
    }

    fun parseWhileIterationStatement(): Statement {
        val origin = here()
        expectThenAdvance(Token.Type.K_WHILE)
        val condition = if (at(Token.Type.S_OPEN_PARENTHESIS)) {
            expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
            val c = parseExpr()
            expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
            c
        } else {
            parseExpr()
        }
        return putOrigin(WhileIterationStatement(condition, parseStatementBlock()), origin)
    }

    fun parseDoWhileIterationStatement(): Statement {
        val origin = here()
        expectThenAdvance(Token.Type.K_DO)
        val statements = parseStatementBlock()
        expectThenAdvance(Token.Type.K_WHILE)
        val condition = if (at(Token.Type.S_OPEN_PARENTHESIS)) {
            expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
            val c = parseExpr()
            expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
            c
        } else {
            parseExpr()
        }
        expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
        return putOrigin(DoWhileIterationStatement(condition, statements), origin)
    }

    fun parseIfSelectionStatement(): Statement {
        val origin = here()
        expectThenAdvance(Token.Type.K_IF)
        val condition = if (at(Token.Type.S_OPEN_PARENTHESIS)) {
            expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
            val c = parseExpr()
            expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
            c
        } else {
            parseExpr()
        }
        val thenStatements = parseStatementBlock()
        val branches = mutableListOf<IfElseBranchStatementNode>()
        while (at(Token.Type.K_ELSE)) {
            advancePointer() // consume "else" part: not useful
            when (peek().type) // before i started with always making that "else-if" part was just "elif" which made parsing a lot easier, but i can see why it really isnt that necessary LOL
            {
                Token.Type.K_IF -> // "else-if" part
                {
                    val subOrigin = peek().canonicalLocation
                    advancePointer()
                    val deepCondition = if (at(Token.Type.S_OPEN_PARENTHESIS)) {
                        expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
                        val dc = parseExpr()
                        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
                        dc
                    } else {
                        parseExpr()
                    }
                    branches.add(putOrigin(ElseIfBranchStatement(deepCondition, parseStatementBlock()), subOrigin))
                }

                else -> branches.add(putOrigin(ElseBranchStatement(parseStatementBlock())))
            }
        }
        return putOrigin(IfSelectionStatement(condition, thenStatements, branches), origin)
    }

    // handles special cases with closing angle which are not tokenized together during the lexer (we use angle brackets for generics smh)
    private fun tryBinaryOps(peekOffset: Int = 0): Array<Token.Type>? {
        return tryInOrder(
            arrayOf(
                arrayOf(Token.Type.S_CLOSE_ANGLE, Token.Type.S_CLOSE_ANGLE, Token.Type.S_CLOSE_ANGLE),
                arrayOf(Token.Type.S_CLOSE_ANGLE, Token.Type.S_CLOSE_ANGLE),
                arrayOf(Token.Type.S_CLOSE_ANGLE, Token.Type.S_EQUAL)
            ),
            peekOffset
        )
    }

    fun parseExpr(minPrecedence: Int = 0): Expr {
        val origin = here()
        var left: Expr = parsePrimaryOrUnaryExpr()
        left = parsePostfix(left)
        while (true) {
            val binOpTokens = tryBinaryOps() ?: arrayOf(peek().type)
            val binaryOpType = BinaryOp.byTokenTypeMaybe(binOpTokens)
            if (binaryOpType == null || binaryOpType.precedence < minPrecedence) {
                break
            }
            repeat(binOpTokens.size) {
                advancePointer() // consume the operators
            }
            // the following binary operators require special parsing of the right hand side so they are put before the others
            if (binaryOpType == BinaryOp.TYPE_CHECK) {
                val right = parseType()
                return putOrigin(TypeCheckExpr(left, right), origin)
            }
            if (binaryOpType == BinaryOp.TYPE_CAST) {
                val right = parseType()
                return putOrigin(TypeCastExpr(left, right), origin)
            }
            val nextMinPrecedence = binaryOpType.precedence + 1
            val right = parseExpr(nextMinPrecedence)
            left = when (binaryOpType) {
                BinaryOp.CONJUNCTIVE_DOT -> MemberAccessExpr(left, right)
                BinaryOp.RANGE -> RangeExpr(left, right)
                else -> BinaryExpr(left, right, binaryOpType)
            }
        }
        return putOrigin(left, origin)
    }

    private fun parsePostfix(baseExpr: Expr): Expr {
        var expr = baseExpr
        while (true) {
            when {
                at(Token.Type.S_OPEN_BRACKET) -> {
                    // array index
                    expectThenAdvance(Token.Type.S_OPEN_BRACKET)
                    val idx = parseExpr()
                    expectThenAdvance(Token.Type.S_CLOSE_BRACKET)
                    expr = putOrigin(
                        ArrayIndexExpr(expr, idx),
                        here()
                    )
                }

                at(Token.Type.S_DOT) -> {
                    advancePointer()
                    val member = parseIdentifier()
                    expr = putOrigin(MemberAccessExpr(expr, member), here())
                }

                at(Token.Type.S_OPEN_PARENTHESIS) -> {
                    // function call on arbitrary expression (e.g., p.dist())
                    val params = parseFunctionCallParameter()
                    expr = putOrigin(FunctionCallExpr(expr, params.second, params.first), here())
                }

                else -> break
            }
        }
        return expr
    }

    private fun parsePrimaryOrUnaryExpr(): Expr {
        return when {
            UnaryOp.byTokenTypeMaybe(peek().type) != null -> parseUnaryExpr()
            else -> parsePrimaryExpr(null)
        }
    }

    fun parsePrimaryExpr(modifier: Map<Modifier, SourcePosition>?): Expr {
        return when (peek().type) {
            // lowkey this hard coded switch statement seems like the best approach, but i get that
            // itch that it will be like redundancy and edge case hell
            Token.Type.L_FLOAT -> parseFloatLiteral()
            Token.Type.L_INTEGER -> parseIntegerLiteral()
            Token.Type.L_STRING -> parseStringLiteral()
            Token.Type.S_OPEN_BRACKET -> parseArrayLiteral()
            Token.Type.INTRINSIC_IDENTIFIER -> {
                // intrinsic tokens are lexed as a single token by the lexer
                val startLoc = peek().canonicalLocation
                val identifier = peek().content
                advancePointer()
                // if followed by '(' parse call-like parameters for intrinsics
                var parameters: List<Expr>? = null
                if (at(Token.Type.S_OPEN_PARENTHESIS)) {
                    parameters = mutableListOf()
                    expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
                    while (!at(Token.Type.S_CLOSE_PARENTHESIS) && !at(Token.Type.S_EOF)) {
                        if (parameters.isNotEmpty()) {
                            expectThenAdvance(Token.Type.S_COMMA)
                        }
                        parameters.add(parsePrimaryWithIndexing())
                    }
                    expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
                }
                val findVal = null // IntrinsicRegistry.entries.find { it.rep == identifier }
                return when (findVal != null) {
//                    true -> putOrigin(
//                        IntrinsicExpr(findVal, startLoc.toLocationFromContext(context), parameters),
//                        startLoc
//                    )

                    else -> Diagnostics.panic(
                        "KiraParser::parsePrimaryExpr",
                        "An intrinsic named '${identifier}' does not exist.",
                        location = startLoc,
                        selectorLength = identifier.length,
                        context = context
                    )
                }
            }

            Token.Type.K_WITH -> parseWithExpr()
            Token.Type.K_MODULE -> parseModuleDecl()
            Token.Type.K_FX -> parseFunctionDecl(modifier)
            Token.Type.IDENTIFIER ->
                when (peek(1).type) {
                    Token.Type.S_OPEN_PARENTHESIS -> {
                        if (modifier?.isNotEmpty() ?: false) {
                            Diagnostics.panic(
                                "KiraParser::parseFunctionCallExpr",
                                "Modifiers are not expected on function calls.",
                                location = here(),
                                selectorLength = 1,
                                context = context
                            )
                        }
                        parseFunctionCallExpr()
                    }

                    Token.Type.S_OPEN_BRACE -> {
                        // Type initialization: only treat as object init if the identifier looks like a type (PascalCase)
                        val ident = peek().content
                        return if (ident.isNotEmpty() && ident[0].isUpperCase()) {
                            parseObjectInit()
                        } else {
                            parseIdentifierExpr(modifier)
                        }
                    }

                    Token.Type.S_OPEN_ANGLE -> {
                        val ident = peek().content
                        if (ident.isNotEmpty() && ident[0].isUpperCase()) {
                            var depth = 0
                            var i = 1
                            var foundBrace = false
                            while (i < 100) { // reasonable lookahead limit
                                val t = peek(i).type
                                if (t == Token.Type.S_OPEN_ANGLE) depth++
                                else if (t == Token.Type.S_CLOSE_ANGLE) {
                                    depth--
                                    if (depth == 0) {
                                        if (peek(i + 1).type == Token.Type.S_OPEN_BRACE) {
                                            foundBrace = true
                                        }
                                        break
                                    }
                                } else if (t == Token.Type.S_EOF) break
                                i++
                            }

                            return if (foundBrace) {
                                parseObjectInit()
                            } else {
                                parseIdentifierExpr(modifier)
                            }
                        } else {
                            parseIdentifierExpr(modifier)
                        }
                    }

                    else -> parseIdentifierExpr(modifier)
                }

            Token.Type.OP_SUB, Token.Type.OP_ADD, Token.Type.S_BANG, Token.Type.S_TILDE -> parseUnaryExpr()
            Token.Type.S_OPEN_PARENTHESIS -> {
                advancePointer()
                val expr = parseExpr()
                expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
                expr
            }

            else ->
                Diagnostics.panic(
                    "KiraParser::parsePrimaryExpr",
                    "${EnglishUtils.prependIndefiniteArticle(peek().type.diagnosticsName())} is not allowed here.",
                    location = peek().canonicalLocation,
                    selectorLength = peek().content.length,
                    context = context
                )
        }
    }

    fun parseModuleDecl(): Decl {
        val origin = here()
        expectThenAdvance(Token.Type.K_MODULE)
        val uri = parseStringLiteral()
        return putOrigin(ModuleDecl(uri), origin)
    }

    fun parseUnaryExpr(): Expr {
        val origin = here()
        val operatorToken = peek()
        expectAnyOfThenAdvance(UnaryOp.entries.map { it.tokenType }.toTypedArray())
        val operand = parseExpr(UnaryOp.NEG.precedence)
        return putOrigin(UnaryExpr(UnaryOp.byTokenTypeMaybe(operatorToken.type) {
            Diagnostics.panic(
                "UnaryOperator::byTokenTypeMaybe",
                "$operatorToken is not an unary operator!",
                context = context,
                location = operatorToken.canonicalLocation,
                selectorLength = operatorToken.content.length
            )
        }!!, operand), origin)
    }

    fun parseBinaryExpr(): Expr {
        val origin = here()
        var left = parsePrimaryExpr(null)
        while (Token.Type.isBinaryOperator(peek().type)) {
            val operator = peek()
            advancePointer()
            val right = parsePrimaryExpr(null)
            left = when (operator.type) {
                Token.Type.S_DOT -> MemberAccessExpr(left, right)
                else -> BinaryExpr(
                    left,
                    right,
                    BinaryOp.byTokenTypeMaybe(arrayOf(operator.type)) {
                        Diagnostics.panic(
                            "BinaryOperator::byTokenTypeMaybe",
                            "$operator is not a binary operator!",
                            context = context,
                            location = operator.canonicalLocation,
                            selectorLength = operator.content.length
                        )
                    }!!
                )
            }
        }
        return putOrigin(left, origin)
    }

    fun parseWithExpr(): Expr {
        val origin = here()
        expectThenAdvance(Token.Type.K_WITH)
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val members = mutableListOf<WithExprMember>()
        while (!at(Token.Type.S_CLOSE_BRACE) && !at(Token.Type.S_EOF)) {
            if (members.isNotEmpty()) {
                expectThenAdvance(Token.Type.S_COMMA)
            }
            val subOrigin = peek().canonicalLocation
            val identifier = parseIdentifier()
            expectThenAdvance(Token.Type.S_EQUAL)
            val expr = parseExpr()
            members.add(putOrigin(WithExprMember(identifier, expr), subOrigin))
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACE)
        return putOrigin(WithExpr(members), origin)
    }

    private fun parseFunctionCallExpr(): FunctionCallExpr {
        val origin = here()
        var identifier by Delegates.notNull<Expr>()
        if (at(Token.Type.INTRINSIC_IDENTIFIER)) {
            identifier = parseIntrinsicExpr()
        } else {
            identifier = parseIdentifier()
        }
        val parameters = parseFunctionCallParameter()
        return putOrigin(FunctionCallExpr(identifier, parameters.second, parameters.first), location = origin)
    }

    fun parseIntrinsicExpr(isFunctionContext: Boolean = false): Expr {
//        val startLoc = peek().canonicalLocation
//        val identifier = peek().content
//        // intrinsic identifiers are lexed as INTRINSIC_IDENTIFIER by the lexer
//        expectThenAdvance(Token.Type.INTRINSIC_IDENTIFIER)
//        var parameters: List<Expr>? = null
//        if (!isFunctionContext && at(Token.Type.S_OPEN_PARENTHESIS)) {
//            parameters = mutableListOf()
//            expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
//            while (!at(Token.Type.S_CLOSE_PARENTHESIS) && !at(Token.Type.S_EOF)) {
//                if (parameters.isNotEmpty()) {
//                    expectThenAdvance(Token.Type.S_COMMA)
//                }
//                parameters.add(parsePrimaryWithIndexing())
//            }
//            expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
//        }
//        val findVal = IntrinsicRegistry.entries.find { it.rep == identifier }
//        return when (findVal != null) {
//            true -> putOrigin(
//                IntrinsicExpr(
//                    findVal,
//                    startLoc.toLocationFromContext(context),
//                    parameters
//                ), startLoc
//            )
//
//            else -> Diagnostics.panic(
//                "KiraParser::parseIntrinsicExpr",
//                "An intrinsic named '${identifier}' does not exist.",
//                location = startLoc,
//                selectorLength = identifier.length,
//                context = context
//            )
//        }
        return NoExpr
    }

    fun parseFunctionDeclParameters(): List<FunctionDeclParameterExpr> {
        // could this be also adapted for future implementations of function notations ??
        val parameters = mutableListOf<FunctionDeclParameterExpr>()
        expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
        while (!at(Token.Type.S_CLOSE_PARENTHESIS) && !at(Token.Type.S_EOF)) {
            if (parameters.isNotEmpty()) {
                expectThenAdvance(Token.Type.S_COMMA)
            }
            val modifiers = parseModifiers()
            val origin = here()
            val name = parseIdentifier()
            expectThenAdvance(Token.Type.S_COLON)
            val type = parseType()
            parameters.add(putOrigin(FunctionDeclParameterExpr(name, type, modifiers.keys.toList()), origin))
        }
        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        return parameters
    }

    private fun parseFunctionDecl(modifier: Map<Modifier, SourcePosition>?): FunctionDecl {
        val origin = here()
        expectModifiers(modifier, WrappingContext.FUNCTION)
        expectThenAdvance(Token.Type.K_FX)
        var functionName: Expr = AnonymousIdentifier
        if (at(Token.Type.INTRINSIC_IDENTIFIER)) {
            functionName = parseIntrinsicExpr(isFunctionContext = true)
        } else if (at(Token.Type.IDENTIFIER)) {
            functionName = parseIdentifier()
        }
        // optional generics: fx name<T, U: Bound> (...)
        val generics = mutableListOf<Type>()
        if (at(Token.Type.S_OPEN_ANGLE)) {
            expectThenAdvance(Token.Type.S_OPEN_ANGLE)
            while (!at(Token.Type.S_CLOSE_ANGLE) && !at(Token.Type.S_EOF)) {
                val param = parseTypeParameter()
                generics.add(param)
                if (!at(Token.Type.S_CLOSE_ANGLE)) expectThenAdvance(Token.Type.S_COMMA)
            }
            expectThenAdvance(Token.Type.S_CLOSE_ANGLE)
        }
        val params = parseFunctionDeclParameters()
        expectThenAdvance(Token.Type.S_COLON)
        val returnType = parseType()
        var body: List<Statement>? = null
        if (at(Token.Type.S_OPEN_BRACE)) {
            body = parseStatementBlock()
        }
        return putOrigin(
            FunctionDecl(
                functionName,
                FunctionDefExpr(returnType, params, body),
                modifier?.keys?.toList() ?: emptyList(),
                generics,
            ), origin
        )
    }

    private fun parseFunctionCallParameter(): Pair<List<FunctionCallNamedParameterExpr>, List<FunctionCallPositionalParameterExpr>> {
        val named = mutableListOf<FunctionCallNamedParameterExpr>()
        val positional = mutableListOf<FunctionCallPositionalParameterExpr>()
        var positionalIndex = 0
        var seenNamed = false
        expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
        while (!at(Token.Type.S_CLOSE_PARENTHESIS) && !at(Token.Type.S_EOF)) {
            if (positional.isNotEmpty() || named.isNotEmpty()) {
                expectThenAdvance(Token.Type.S_COMMA)
            }
            val startToken = peek()
            if (at(Token.Type.IDENTIFIER) && peek(1).type == Token.Type.S_EQUAL) {
                seenNamed = true
                val origin = here()
                val identifier = parseIdentifier()
                expectThenAdvance(Token.Type.S_EQUAL)
                val expr = parseExpr()
                if (expr is CompoundAssignmentExpr || expr is AssignmentExpr) {
                    Diagnostics.panic(
                        "KiraParser::parseFunctionCallParameter",
                        "Cannot use assignment expressions in function call parameters",
                        context = context,
                        location = startToken.canonicalLocation,
                        selectorLength = startToken.content.length
                    )
                }
                named.add(putOrigin(FunctionCallNamedParameterExpr(identifier, expr), origin))
            } else {
                if (seenNamed) {
                    Diagnostics.panic(
                        "KiraParser::parseFunctionCallParameter",
                        "Positional arguments must come before named arguments",
                        context = context,
                        location = startToken.canonicalLocation,
                        selectorLength = startToken.content.length
                    )
                }
                val origin = here()
                val expr = parsePrimaryWithIndexing()
                if (expr is CompoundAssignmentExpr || expr is AssignmentExpr) {
                    Diagnostics.panic(
                        "KiraParser::parseFunctionCallParameter",
                        "Cannot use assignment expressions in function call parameters",
                        context = context,
                        location = startToken.canonicalLocation,
                        selectorLength = startToken.content.length
                    )
                }
                positional.add(putOrigin(FunctionCallPositionalParameterExpr(positionalIndex++, expr), origin))
            }
        }
        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        return named to positional
    }


    private fun parseIdentifierExpr(modifier: Map<Modifier, SourcePosition>?): Expr {
        if (tryCompoundAssignmentOperators(1) != null) // skip the identifier with peekoffset +1 (similar to why we also peek(1) below in the when statement
        {
            return parseCompoundAssignmentExpr()
        }
        return when (peek(1).type) {
            Token.Type.S_EQUAL -> parseAssignmentExpr()
            Token.Type.S_COLON -> parseVariableDecl(modifier)
            else -> parseIdentifier()
        }
    }

    fun parseUseStatement(): Statement {
        val origin = here()
        expectThenAdvance(Token.Type.K_USE)
        val uri = parseStringLiteral()
        return putOrigin(UseStatement(uri), origin)
    }

    // helper function for dealing with compound assignment operators that utilize the closing angle bracket (which is a pain to disambiguate) <-- this is a fucking word!?!?!
    fun tryCompoundAssignmentOperators(peekOffset: Int = 0): Array<Token.Type>? {
        return tryInOrder(
            arrayOf(
                arrayOf(
                    Token.Type.S_CLOSE_ANGLE, Token.Type.S_CLOSE_ANGLE, Token.Type.S_CLOSE_ANGLE, Token.Type.S_EQUAL
                ), arrayOf(
                    Token.Type.S_CLOSE_ANGLE, Token.Type.S_CLOSE_ANGLE, Token.Type.S_EQUAL
                )
            ),
            peekOffset,
        )
    }

    fun parseCompoundAssignmentExpr(): CompoundAssignmentExpr {
        val origin = here()
        val left = parseIdentifier() // todo: allow for more than just identifiers for now
        val opTokens: Array<Token.Type> = tryCompoundAssignmentOperators() ?: arrayOf(peek().type)
        val op = CompoundAssignmentExpr.findBinaryOp(opTokens)
        repeat(opTokens.size) { advancePointer() }
        val right = parseExpr()
        return putOrigin(CompoundAssignmentExpr(left, op!!, right), origin)
    }


    fun parseAssignmentExpr(): AssignmentExpr {
        val origin = here()
        val identifier = parseIdentifier()
        expectThenAdvance(Token.Type.S_EQUAL)
        val value = parseBinaryExpr()
//        if (identifier !is Identifier) {
//            Diagnostics.panic(
//                "KiraParser::parseAssignmentExpr",
//                "Assignment expressions can only use identifiers for l-value.",
//                context = context,
//                location = context.astOrigins[identifier] ?: origin,
//            )
//        }
        return putOrigin(AssignmentExpr(identifier, value), origin)
    }

    fun parseEnumMemberExpr(): EnumMemberExpr {
        val origin = here()
        val name = parseIdentifier()
        var value: DataLiteral<*>? = null
        if (at(Token.Type.S_EQUAL)) {
            expectThenAdvance(Token.Type.S_EQUAL)
            val start = peek()
            val parseValue = parsePrimaryExpr(null)
            if (parseValue !is SimpleLiteral && parseValue !is DataLiteral<*>) {
                Diagnostics.panic(
                    "KiraParser::parseEnumMemberExpr",
                    "Only simple literals are allowed as enum values. That is strings, booleans, floats, and integers.",
                    location = start.canonicalLocation,
                    selectorLength = start.content.length,
                    context = context
                )
            }
            value = parseValue as DataLiteral<*>
        }
//        if (name !is Identifier) {
//            Diagnostics.panic(
//                "KiraParser::parseEnumMemberExpr",
//                "Enum members can only be named using identifiers.",
//                context = context,
//                location = context.astOrigins[name] ?: origin,
//            )
//        }
        return putOrigin(EnumMemberExpr(name, value), origin)
    }

    fun parseEnumDecl(modifier: Map<Modifier, SourcePosition>?): EnumDecl {
        expectModifiers(modifier, WrappingContext.ENUM)
        advancePointer() // consume 'enum'
        val origin = here()
        val name = parseIdentifier() // we only allow simple names, not complex names on enums, cuz there is no point
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val members = mutableListOf<EnumMemberExpr>()
        while (!at(Token.Type.S_CLOSE_BRACE) && !at(Token.Type.S_EOF)) {
            members.add(parseEnumMemberExpr())
            if (!at(Token.Type.S_CLOSE_BRACE)) {
                expectThenAdvance(Token.Type.S_COMMA)
            }
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACE)
//        if (name !is Identifier) {
//            Diagnostics.panic(
//                "KiraParser::parseEnumDecl",
//                "Enum declarations can only use identifiers for their name.",
//                context = context,
//                location = context.astOrigins[name] ?: origin,
//            )
//        }
        return putOrigin(EnumDecl(name, members.toTypedArray(), modifier?.keys?.toList() ?: emptyList()), origin)
    }

    fun parseTypeAliasExpr(modifiers: Map<Modifier, SourcePosition>?): TypeAliasDecl {
        expectModifiers(modifiers, WrappingContext.TYPE_ALIAS)
        val origin = here()
        expectThenAdvance(Token.Type.K_ALIAS)
        val aliasType = parseType()
        expectThenAdvance(Token.Type.K_AS)
        val targetType = parseType()
        return putOrigin(TypeAliasDecl(modifiers?.let { modifiers.keys.toList() } ?: emptyList(),
            aliasType,
            targetType), origin)
    }


    fun parseClassDecl(modifier: Map<Modifier, SourcePosition>?): ClassDecl {
        expectModifiers(modifier, WrappingContext.CLASS)
        advancePointer() //consume the class keyword
        val origin = here()
        val className = parseType()
        val parenTypes = mutableListOf<Type>()
        if (at(Token.Type.S_COLON)) // inheritance here baby ;D
        {
            advancePointer()
            while (!at(Token.Type.S_OPEN_BRACE) && !at(Token.Type.S_EOF)) {
                val parentType = parseType()
                parenTypes.add(parentType)
                if (at(Token.Type.S_COMMA)) {
                    advancePointer()
                } else {
                    break
                }
            }
        }
        if (!at(Token.Type.S_OPEN_BRACE)) {
            val classDecl = ClassDecl(className, modifier?.keys?.toList() ?: emptyList(), emptyList(), parenTypes)
            attachIntrinsics(classDecl)
            return putOrigin(classDecl, origin)
        }
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val members = mutableListOf<FirstClassDecl>()
        while (!at(Token.Type.S_CLOSE_BRACE) && !at(Token.Type.S_EOF)) {
            val memberModifiers = parseModifiers()
            expectModifiers(memberModifiers, WrappingContext.CLASS_MEMBER)
            members.add(
                if (at(Token.Type.S_OPEN_PARENTHESIS)) // check for simple/anonymous function literals
                {
                    Diagnostics.panic(
                        "KiraParser::parseClassDecl",
                        "Anonymous Function Literals are not allowed by themselves in a class.",
                        location = peek().canonicalLocation,
                        selectorLength = peek().content.length,
                        context = context
                    )
                } else if (peek(1).type == Token.Type.S_COLON) {
                    val valDecl = parseVariableDecl(memberModifiers)
                    expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                    valDecl
                } else {
                    parseFunctionDecl(memberModifiers) // if this throws, then it is 99.99% user error
                }
            )
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACE)
        val classDecl = ClassDecl(className, modifier?.keys?.toList() ?: emptyList(), members, parenTypes)
        attachIntrinsics(classDecl)
        return putOrigin(classDecl, origin)
    }

    fun parseVariantDecl(modifier: Map<Modifier, SourcePosition>?): VariantDecl {
        expectModifiers(modifier, WrappingContext.CLASS)
        advancePointer() // consume 'variant'
        val origin = here()
        val variantName = parseType()
        val parenTypes = mutableListOf<Type>()
        if (at(Token.Type.S_COLON)) {
            advancePointer()
            while (!at(Token.Type.S_OPEN_BRACE) && !at(Token.Type.S_EOF)) {
                val parentType = parseType()
                parenTypes.add(parentType)
                if (at(Token.Type.S_COMMA)) {
                    advancePointer()
                } else {
                    break
                }
            }
        }
        if (!at(Token.Type.S_OPEN_BRACE)) {
            val decl =
                VariantDecl(variantName, modifier?.keys?.toList() ?: emptyList(), emptyList(), emptyList(), parenTypes)
            attachIntrinsics(decl)
            return putOrigin(decl, origin)
        }
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val variants = mutableListOf<ClassDecl>()
        val members = mutableListOf<FirstClassDecl>()
        while (!at(Token.Type.S_CLOSE_BRACE) && !at(Token.Type.S_EOF)) {
            val memberModifiers = parseModifiers()
            expectModifiers(memberModifiers, WrappingContext.CLASS_MEMBER)
            if (at(Token.Type.K_CLASS)) {
                // parse inner class which acts as a variant
                val classDecl = parseClassDecl(memberModifiers)
                variants.add(classDecl)
            } else if (peek(1).type == Token.Type.S_COLON) {
                val valDecl = parseVariableDecl(memberModifiers)
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                members.add(valDecl)
            } else {
                val func = parseFunctionDecl(memberModifiers)
                members.add(func)
            }
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACE)
        val decl = VariantDecl(variantName, modifier?.keys?.toList() ?: emptyList(), variants, members, parenTypes)
        attachIntrinsics(decl)
        return putOrigin(decl, origin)
    }

    fun parseTraitDecl(modifier: Map<Modifier, SourcePosition>?): TraitDecl {
        expectModifiers(modifier, WrappingContext.TRAIT)
        val baseLocation = here()
        var seenAnonymous = false
        expectThenAdvance(Token.Type.K_TRAIT)
        val name = parseType()
        val parenTypes = mutableListOf<Type>()
        if (at(Token.Type.S_COLON)) {
            advancePointer()
            while (!at(Token.Type.S_OPEN_BRACE) && !at(Token.Type.S_EOF)) {
                val parentType = parseType()
                parenTypes.add(parentType)
                if (at(Token.Type.S_COMMA)) {
                    advancePointer()
                } else {
                    break
                }
            }
        }
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val members = mutableListOf<FunctionDecl>()
        while (!at(Token.Type.S_CLOSE_BRACE) && !at(Token.Type.S_EOF)) {
            val memberModifiers = parseModifiers()
            expectModifiers(memberModifiers, WrappingContext.TRAIT_MEMBER)
            val memberExpr = parseFunctionDecl(memberModifiers)
            // check if we have seen an anonymous function against this member (we only permit one anonymous function)
            if (memberExpr.isAnonymous()) {
                if (seenAnonymous) {
                    Diagnostics.panic(
                        "KiraParser::parseTraitDecl",
                        "Traits only allow 1 anonymous function. Either give this function name or remove others.",
                        context = context,
                        location = context.astOrigins[memberExpr],
                        selectorLength = context.findCanonicalLine(context.astOrigins[memberExpr]!!.lineNumber).length
                    )
                }
                seenAnonymous = true
            }
            members.add(memberExpr)
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACE)
        if (members.isEmpty()) {
            Diagnostics.Logging.warn(
                "KiraParser::parseTraitDecl",
                "Found trait $name with no members."
            )
        }
        return putOrigin(
            TraitDecl(name, modifier?.keys?.toTypedArray() ?: emptyArray(), members, parenTypes),
            baseLocation,
        )
    }

    fun parseVariableDecl(modifier: Map<Modifier, SourcePosition>?): VariableDecl {
        expectModifiers(modifier, WrappingContext.VARIABLE)
        val origin = here()
        val identifier = parseIdentifier()
        expectThenAdvance(Token.Type.S_COLON)
        val type = parseType()
        var value: Expr? = null
        if (at(Token.Type.S_EQUAL)) {
            advancePointer()
            value = parseExpr()
        }
//        Diagnostics.Logging.info("LOG", "${context.file} @ $origin -> ${identifier.value}")
        return putOrigin(VariableDecl(identifier, type, value, modifier?.keys?.toList() ?: emptyList()), origin)
    }


    fun parseStringLiteral(): StringLiteral {
        val value = peek().content
        val origin = here()
        expectThenAdvance(Token.Type.L_STRING)
        return putOrigin(StringLiteral(value), origin)
    }

    fun parseArrayLiteral(): ArrayLiteral {
        val origin = here()
        expectThenAdvance(Token.Type.S_OPEN_BRACKET)
        val elements = mutableListOf<Expr>()
        while (!at(Token.Type.S_CLOSE_BRACKET) && !at(Token.Type.S_EOF)) {
            elements.add(parsePrimaryExpr(null))
            if (!at(Token.Type.S_CLOSE_BRACKET)) {
                expectThenAdvance(Token.Type.S_COMMA)
            }
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACKET)
        return putOrigin(ArrayLiteral(elements.toTypedArray()), origin)
    }

    fun parseIntegerLiteral(): IntegerLiteral {
        var value by Delegates.notNull<Long>()
        val origin = here()
        try {
            value = peek().content.toLong()
        } catch (e: Exception) {
            Diagnostics.panic(
                "KiraParser::parseIntegerLiteral",
                "Unable to read '${peek().content}' as an integer literal",
                cause = e,
                location = origin,
                selectorLength = peek().content.length,
                context = context
            )
        }
        expectThenAdvance(Token.Type.L_INTEGER)
        return putOrigin(IntegerLiteral(value), origin)
    }

    fun parseFloatLiteral(): FloatLiteral {
        var value by Delegates.notNull<Double>()
        val origin = here()
        try {
            value = peek().content.toDouble()
        } catch (e: Exception) {
            Diagnostics.panic(
                "KiraParser::parseIntegerLiteral",
                "Unable to read '${peek().content}' as an integer literal",
                cause = e,
                location = peek().canonicalLocation,
                selectorLength = peek().content.length,
                context = context
            )
        }
        expectThenAdvance(Token.Type.L_FLOAT)
        return putOrigin(FloatLiteral(value), origin)
    }

    fun parseIdentifier(): Identifier {
        val loc = peek().canonicalLocation
        val value = peek().content
        expectThenAdvance(Token.Type.IDENTIFIER)
        return putOrigin(Identifier(value), loc)
    }

    private fun parseTypeParameter(): Type {
        var bound: Type? = null
        fun acquireTypeBound() {
            if (at(Token.Type.S_COLON)) {
                advancePointer()
                bound = parseType()
            }
        }

        val baseLocation = here()
        val baseIdentifier = parseIdentifier()
        val children = mutableListOf<Type>()
        if (at(Token.Type.S_OPEN_ANGLE)) {
            expectThenAdvance(Token.Type.S_OPEN_ANGLE)
            while (!at(Token.Type.S_CLOSE_ANGLE) && !at(Token.Type.S_EOF)) {
                val param = parseTypeParameter()
                children.add(param)
                if (!at(Token.Type.S_CLOSE_ANGLE)) {
                    expectThenAdvance(Token.Type.S_COMMA)
                }
            }
            expectThenAdvance(Token.Type.S_CLOSE_ANGLE)
        } else {
            acquireTypeBound()
        }

        return putOrigin(Type(baseIdentifier, bound, children), baseLocation)
    }


    fun parseType(): Type {
        val baseLocation = here()
        val baseIdentifier = parseIdentifier()
        if (!at(Token.Type.S_OPEN_ANGLE)) {
            return putOrigin(Type(baseIdentifier), baseLocation)
        }
        expectThenAdvance(Token.Type.S_OPEN_ANGLE)
        val children = mutableListOf<Type>()
        while (!at(Token.Type.S_CLOSE_ANGLE) && !at(Token.Type.S_EOF)) {
            val param = parseTypeParameter()
            children.add(param)
            if (!at(Token.Type.S_CLOSE_ANGLE)) {
                expectThenAdvance(Token.Type.S_COMMA)
            }
        }
        expectThenAdvance(Token.Type.S_CLOSE_ANGLE)
        return putOrigin(Type(baseIdentifier, null, children), baseLocation)

    }

    fun parseModifiers(): Map<Modifier, SourcePosition> {
        val modifier = mutableMapOf<Modifier, SourcePosition>()
        val intrinsics = mutableListOf<IntrinsicRegistry>()
        while (at(Token.Type.INTRINSIC_IDENTIFIER)) {
            val intrinsicName = peek().content
//            val intrinsic = IntrinsicRegistry.entries.find { it.rep == intrinsicName }
//            if (intrinsic != null) {
//                intrinsics.add(intrinsic)
//            }
            advancePointer()
        }
        while (peek().type in Token.Type.modifiers) {
            val currentModifier = Modifier.byTokenTypeMaybe(peek().type) {
                Diagnostics.panic(
                    "KiraParser::parseModifiers",
                    "${peek()} is not a valid modifier",
                    context = context,
                    location = peek().canonicalLocation,
                    selectorLength = peek().content.length,
                )
            }
            modifier[currentModifier]?.let {
                Diagnostics.panic(
                    "KiraParser::parseModifiers", "Duplicate modifier at ${peek().canonicalLocation}",
                    context = context,
                    location = peek().canonicalLocation,
                    selectorLength = peek().content.length,
                )
            }
            modifier[currentModifier!!] = peek().canonicalLocation
            advancePointer()
        }
        if (intrinsics.isNotEmpty()) {
            pendingIntrinsics = intrinsics.toTypedArray()
        }
        return modifier
    }

    private var pendingIntrinsics: Array<IntrinsicRegistry>? = null

    private fun <T : ASTNode> attachIntrinsics(node: T): T {
        if (pendingIntrinsics != null) {
            context.astIntrinsicMarked[node] = pendingIntrinsics!!
            pendingIntrinsics = null
        }
        return node
    }

    private fun parseObjectInit(): ObjectInitExpr {
        val origin = here()
        val typeName = parseType()
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val args = mutableListOf<Expr>()
        while (!at(Token.Type.S_CLOSE_BRACE) && !at(Token.Type.S_EOF)) {
            if (args.isNotEmpty()) {
                expectThenAdvance(Token.Type.S_COMMA)
            }
            args.add(parseExpr())
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACE)
        return putOrigin(ObjectInitExpr(typeName, args), origin)
    }

    private fun parsePrimaryWithIndexing(): Expr {
        val base = parsePrimaryOrUnaryExpr()
        return parsePostfix(base)
    }

    fun parseThrowStatement(): Statement {
        val origin = here()
        if (at(Token.Type.K_THROW)) {
            expectThenAdvance(Token.Type.K_THROW)
        } else if (at(Token.Type.IDENTIFIER) && peek().content == "throw") {
            advancePointer()
        } else {
            Diagnostics.panic(
                "KiraParser::parseThrowStatement",
                "Expected 'throw' here.",
                location = here(),
                context = context
            )
        }
        val expr = parseExpr()
        expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
        val throwNode = putOrigin(ThrowExpr(expr), origin)
        return putOrigin(Statement(throwNode), origin)
    }

    fun parseTryStatement(): Statement {
        val origin = here()
        if (at(Token.Type.K_TRY)) {
            expectThenAdvance(Token.Type.K_TRY)
        } else if (at(Token.Type.IDENTIFIER) && peek().content == "try") {
            advancePointer()
        } else {
            Diagnostics.panic(
                "KiraParser::parseTryStatement",
                "Expected 'try' here.",
                location = here(),
                context = context
            )
        }
        val tryBlock = parseStatementBlock()
        if (at(Token.Type.K_ON) || (at(Token.Type.IDENTIFIER) && peek().content == "on")) {
            if (at(Token.Type.K_ON)) expectThenAdvance(Token.Type.K_ON) else advancePointer()
            val name = parseIdentifier()
            expectThenAdvance(Token.Type.S_COLON)
            val type = parseType()
            val handlerBlock = parseStatementBlock()
            val tryNode = putOrigin(
                TryExpr(
                    tryBlock,
                    name,
                    type,
                    handlerBlock
                ), origin
            )
            return putOrigin(Statement(tryNode), origin)
        }
        val tryNode = putOrigin(
            TryExpr(
                tryBlock,
                null,
                null,
                emptyList()
            ), origin
        )
        return putOrigin(Statement(tryNode), origin)
    }
}
