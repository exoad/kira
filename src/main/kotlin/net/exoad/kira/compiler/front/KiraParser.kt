package net.exoad.kira.compiler.front

import net.exoad.kira.Builtin
import net.exoad.kira.Symbols
import net.exoad.kira.compiler.Diagnostics
import net.exoad.kira.compiler.Intrinsic
import net.exoad.kira.compiler.front.KiraParser.look
import net.exoad.kira.compiler.front.KiraParser.peek
import net.exoad.kira.compiler.front.KiraParser.pointer
import net.exoad.kira.compiler.front.elements.*
import net.exoad.kira.compiler.front.exprs.*
import net.exoad.kira.compiler.front.exprs.decl.ClassDecl
import net.exoad.kira.compiler.front.exprs.decl.FirstClassDecl
import net.exoad.kira.compiler.front.exprs.decl.FunctionFirstClassDecl
import net.exoad.kira.compiler.front.exprs.decl.VariableFirstClassDecl
import net.exoad.kira.compiler.front.statements.*
import kotlin.properties.Delegates

abstract class ASTNode
{
    abstract fun accept(visitor: ASTVisitor)
}

abstract class ASTVisitor
{
    // STATEMENTS
    abstract fun visitStatement(statement: Statement)
    abstract fun visitIfSelectionStatement(ifSelectionStatement: IfSelectionStatement)
    abstract fun visitIfElseIfBranchStatement(ifElseIfBranchNode: ElseIfBranchStatement)
    abstract fun visitElseBranchStatement(elseBranchNode: ElseBranchStatement)
    abstract fun visitWhileIterationStatement(whileIterationStatement: WhileIterationStatement)
    abstract fun visitDoWhileIterationStatement(doWhileIterationStatement: DoWhileIterationStatement)
    abstract fun visitReturnStatement(returnStatement: ReturnStatement)

    // Expressions
    abstract fun visitBinaryExpr(binaryExpr: BinaryExpr)
    abstract fun visitUnaryExpr(unaryExpr: UnaryExpr)
    abstract fun visitAssignmentExpr(assignmentExpr: AssignmentExpr)
    abstract fun visitFunctionCallExpr(functionCallExpr: FunctionCallExpr)
    abstract fun visitIntrinsicCallExpr(intrinsicCallExpr: IntrinsicCallExpr)
    abstract fun visitCompoundAssignmentExpr(compoundAssignmentExpr: CompoundAssignmentExpr)
    abstract fun visitFunctionParameterExpr(functionParameterExpr: FunctionParameterExpr)
    abstract fun visitMemberAccessExpr(memberAccessExpr: MemberAccessExpr)

    // LITERALS
    abstract fun visitIntegerLiteral(integerLiteral: IntegerLiteral)
    abstract fun visitStringLiteral(stringLiteral: StringLiteral)
    abstract fun visitBoolLiteral(boolLiteral: BoolLiteral)
    abstract fun visitFloatLiteral(floatLiteral: FloatLiteral)

    // IDENTIFIERS
    abstract fun visitIdentifier(identifier: Identifier)
    abstract fun visitType(typeNode: Type)

    // DECLARATIONS
    abstract fun visitVariableDecl(variableDecl: VariableFirstClassDecl)
    abstract fun visitFunctionDecl(functionDecl: FunctionFirstClassDecl)
    abstract fun visitClassDecl(classDecl: ClassDecl)
}

class RootASTNode(val statements: List<ASTNode>) : ASTNode()
{
    override fun accept(visitor: ASTVisitor)
    {
        statements.forEach { it.accept(visitor) }
    }
}
/**
 * A semi-naive LL(k) parser that strays from rollbacks as much as possible. It takes
 * the tokens generated by the [KiraLexer] and uses those to turn them into an AST.
 *
 * It will then pass this AST onto the [KiraStaticAnalyzer] to make sure the AST is
 * valid grammar.
 */
object KiraParser
{
    private var pointer: Int = 0
    private var underPointer: Token

    init
    {
        underPointer = if(TokensProvider.tokens.isEmpty()) Token.Symbol(
            Token.Type.S_EOF,
            Symbols.NULL,
            0,
            FileLocation(1, 1)
        )
        else TokensProvider.tokens.first()
    }
    /**
     * Grabs the token at the [k]-th position (absolute).
     *
     * If you need relative positioning, take a look at [peek]
     */
    fun look(k: Int): Token
    {
        val index = pointer + k - 1
        return when
        {
            index < TokensProvider.tokens.size -> TokensProvider.tokens[index]
            else                               -> Token.Symbol(Token.Type.S_EOF, Symbols.NULL, 0, FileLocation(1, 1))
        }
    }
    /**
     * Grabs the token [k] away from [pointer] (relative).
     *
     * If you need absolute positioning, take a look at [look]
     */
    fun peek(k: Int = 0): Token
    {
        val index = pointer + k
        return when
        {
            index < TokensProvider.tokens.size -> TokensProvider.tokens[index]
            else                               -> Token.Symbol(Token.Type.S_EOF, Symbols.NULL, 0, FileLocation(1, 1))
        }
    }
    /**
     * Moves the pointer forward to the next token and thus "consumes" the current token
     */
    fun advancePointer()
    {
        pointer++
        underPointer = when
        {
            pointer < TokensProvider.tokens.size -> TokensProvider.tokens[pointer]
            else                                 -> Token.Symbol(
                Token.Type.S_EOF, Symbols.NULL, 0,
                FileLocation(1, 1)
            )
        }
    }

    fun expectOptionalThenAdvance(token: Token.Type)
    {
        if(underPointer.type == token)
        {
            advancePointer()
        }
    }

    fun expectThenAdvance(token: Token.Type, ifOk: () -> Unit = { advancePointer() })
    {
        when(underPointer.type != token)
        {
            true ->
                Diagnostics.panic(
                    "KiraParser::expect",
                    "Expected ${token.diagnosticsName()} but got ${underPointer.type.diagnosticsName()}",
                    location = underPointer.canonicalLocation,
                    selectorLength = underPointer.content.length
                )
            else -> ifOk()
        }
    }

    fun expectAnyOfThenAdvance(
        tokens: Array<Token.Type>,
        ifOk: () -> Unit =
            { advancePointer() },
    )
    {
        when
        {
            !tokens.contains(underPointer.type) ->
                Diagnostics.panic(
                    "KiraParser::expect",
                    "Expected any of ${tokens.map { it.diagnosticsName() }} but got ${underPointer.type.diagnosticsName()}",
                    location = underPointer.canonicalLocation
                )

            else                                -> ifOk()
        }
    }

    fun parseProgram()
    {
        val statements = mutableListOf<ASTNode>()
        while(underPointer.type != Token.Type.S_EOF)
        {
            statements.add(parseStatement())
        }
        TokensProvider.rootASTNode = RootASTNode(statements)
    }

    fun parseStatement(): Statement
    {
        return when(underPointer.type)
        {
            // parse keywords stuffs first if possible (like keyword first statements)
            Token.Type.K_RETURN     -> parseReturnStatement()
            Token.Type.K_IF         -> parseIfSelectionStatement()
            Token.Type.K_WHILE      -> parseWhileIterationStatement()
            Token.Type.K_DO         -> parseDoWhileIterationStatement()
            in Token.Type.modifiers ->
            {
                val modifiers = parseModifiers()
                val expr = when(underPointer.type)
                {
                    Token.Type.K_CLASS -> parseClassDecl(modifiers)
                    else               -> parsePrimaryExpr(modifiers)
                }
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                return Statement(expr)
            }
            else                    ->
            {
                val expr = parseExpr()
                if(underPointer.type == Token.Type.L_INTEGER || underPointer.type == Token.Type.IDENTIFIER)
                {
                    Diagnostics.panic(
                        "KiraParser::parseStatement",
                        "Unexpected token '${underPointer.content}' after expression",
                        location = underPointer.canonicalLocation,
                        selectorLength = underPointer.content.length
                    )
                }
                expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
                Statement(expr)
            }
        }
    }
    /**
     * Used to parse a statement between two `{}` AKA a block.
     */
    private fun parseStatementBlock(): List<Statement>
    {
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val statements = mutableListOf<Statement>()
        while(underPointer.type != Token.Type.S_CLOSE_BRACE && underPointer.type != Token.Type.S_EOF)
        {
            statements.add(parseStatement())
        }
        expectThenAdvance(Token.Type.S_CLOSE_BRACE)
        return statements
    }

    fun parseReturnStatement(): Statement
    {
        expectThenAdvance(Token.Type.K_RETURN)
        val expr = parseExpr()
        expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
        return ReturnStatement(expr)
    }

    fun parseWhileIterationStatement(): Statement
    {
        expectThenAdvance(Token.Type.K_WHILE)
        expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
        val condition = parseExpr()
        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        return WhileIterationStatement(condition, parseStatementBlock())
    }

    fun parseDoWhileIterationStatement(): Statement
    {
        expectThenAdvance(Token.Type.K_DO)
        val statements = parseStatementBlock()
        expectThenAdvance(Token.Type.K_WHILE)
        expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
        val condition = parseExpr()
        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        expectOptionalThenAdvance(Token.Type.S_SEMICOLON)
        return DoWhileIterationStatement(condition, statements)
    }

    fun parseIfSelectionStatement(): Statement
    {
        expectThenAdvance(Token.Type.K_IF)
        expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
        val condition = parseExpr()
        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        val thenStatements = parseStatementBlock()
        val branches = mutableListOf<IfElseBranchStatementNode>()
        while(underPointer.type == Token.Type.K_ELSE)
        {
            advancePointer() // consume "else" part: not useful
            when(underPointer.type)
            {
                Token.Type.K_IF -> // "else-if" part
                {
                    advancePointer()
                    expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
                    val deepCondition = parseExpr()
                    expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
                    branches.add(ElseIfBranchStatement(deepCondition, parseStatementBlock()))
                }

                else            -> branches.add(ElseBranchStatement(parseStatementBlock()))
            }
        }
        return IfSelectionStatement(condition, thenStatements, branches)
    }

    fun parseExpr(minPrecedence: Int = 0): Expr
    {
        var left: Expr = parsePrimaryOrUnaryExpr()
        while(true)
        {
            val binaryOpType = BinaryOp.byTokenTypeMaybe(underPointer.type)
            if(binaryOpType == null || binaryOpType.precedence < minPrecedence)
            {
                break
            }
            advancePointer()
            val nextMinPrecedence = binaryOpType.precedence + 1
            val right = parseExpr(nextMinPrecedence)
            left =
                when(binaryOpType)
                {
                    BinaryOp.CONJUNCTIVE_DOT -> MemberAccessExpr(left, right)
                    else                     -> BinaryExpr(left, right, binaryOpType)
                }
        }
        return left
    }

    private fun parsePrimaryOrUnaryExpr(): Expr
    {
        return when
        {
            UnaryOp.byTokenTypeMaybe(underPointer.type) != null -> parseUnaryExpr()
            else                                                -> parsePrimaryExpr()
        }
    }

    fun parsePrimaryExpr(modifiers: List<Modifiers>? = null): Expr
    {
        return when(underPointer.type)
        {
            Token.Type.L_FLOAT                                                          -> parseFloatLiteral()
            Token.Type.L_INTEGER                                                        -> parseIntegerLiteral()
            Token.Type.L_STRING                                                         -> parseStringLiteral()
            Token.Type.S_AT                                                             ->
                when(peek(1).type)
                {
                    Token.Type.IDENTIFIER ->
                    {
                        advancePointer()
                        parseIntrinsicCallExpr()
                    }

                    else                  -> Diagnostics.panic(
                        "KiraParser::parsePrimaryExpr",
                        "Intrinsics must be followed by an identifier, but found '${peek(1).type.diagnosticsName()}'",
                        location = underPointer.canonicalLocation,
                        selectorLength = peek(1).content.length
                    )
                }
            Token.Type.IDENTIFIER                                                       ->
                when(peek(1).type)
                {
                    Token.Type.S_OPEN_PARENTHESIS -> parseFunctionCallOrDeclExpr(modifiers)
                    else                          -> parseIdentifierExpr(modifiers)
                }
            Token.Type.L_TRUE_BOOL, Token.Type.L_FALSE_BOOL                             -> parseBoolLiteral()
            Token.Type.OP_SUB, Token.Type.OP_ADD, Token.Type.S_BANG, Token.Type.S_TILDE -> parseUnaryExpr()
            Token.Type.S_OPEN_PARENTHESIS                                               ->
            {
                advancePointer()
                val expr = parseExpr()
                expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
                expr
            }
            else                                                                        -> Diagnostics.panic(
                "KiraParser::parsePrimaryExpr",
                "${
                    when(underPointer.type.rawDiagnosticsRepresentation)
                    {
                        null -> "'${underPointer.content}'"
                        else -> underPointer.type.diagnosticsName()
                    }
                } is not allowed",
                location = underPointer.canonicalLocation,
                selectorLength = underPointer.content.length
            )
        }
    }

    fun parseUnaryExpr(): Expr
    {
        val operatorToken = underPointer
        expectAnyOfThenAdvance(UnaryOp.entries.map { it.tokenType }.toTypedArray())
        val operand = parseExpr(UnaryOp.NEG.precedence)
        return UnaryExpr(UnaryOp.byTokenType(operatorToken.type), operand)
    }

    fun parseBinaryExpr(): Expr
    {
        var left = parsePrimaryExpr()
        while(Token.Type.isBinaryOperator(underPointer.type))
        {
            val operator = underPointer
            advancePointer()
            val right = parsePrimaryExpr()
            left = when(operator.type)
            {
                Token.Type.S_DOT -> MemberAccessExpr(left, right)
                else             -> BinaryExpr(
                    left,
                    right,
                    BinaryOp.byTokenType(operator.type)
                )
            }
        }
        return left
    }

    fun parseIntrinsicCallExpr(): Expr
    {
        val startLoc = underPointer.canonicalLocation
        val identifier = parseIdentifier()
        expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
        val parameters = mutableListOf<Expr>()
        while(underPointer.type != Token.Type.S_CLOSE_PARENTHESIS)
        {
            if(parameters.isNotEmpty())
            {
                expectThenAdvance(Token.Type.S_COMMA)
            }
            parameters.add(parseExpr())
        }
        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        val findVal = Builtin.Intrinsics.entries.find { it.rep == identifier.name }
        return when(findVal != null)
        {
            true -> IntrinsicCallExpr(
                Intrinsic(
                    findVal,
                    AbsoluteFileLocation(
                        underPointer.canonicalLocation.lineNumber,
                        underPointer.canonicalLocation.column,
                        SrcProvider.srcFile
                    )
                ), parameters
            )

            else -> Diagnostics.panic(
                "KiraParser::parseIntrinsicCallExpr",
                "Could not find a compile time intrinsic named '${identifier.name}'",
                location = startLoc,
                selectorLength = identifier.name.length
            )
        }
    }

    fun parseFunctionParameters(): List<FunctionParameterExpr>
    {
        val parameters = mutableListOf<FunctionParameterExpr>()
        while(underPointer.type != Token.Type.S_CLOSE_PARENTHESIS && underPointer.type != Token.Type.S_EOF)
        {
            if(parameters.isNotEmpty())
            {
                expectThenAdvance(Token.Type.S_COMMA)
            }
            val modifiers = parseModifiers()
            val name = parseIdentifier()
            expectThenAdvance(Token.Type.S_COLON)
            val type = parseType()
            parameters.add(FunctionParameterExpr(name, type, modifiers))
        }
        return parameters
    }

    fun parseFunctionCallOrDeclExpr(modifiers: List<Modifiers>? = null): Expr
    {
        val identifier = parseIdentifier()
        expectThenAdvance(Token.Type.S_OPEN_PARENTHESIS)
        return when(isFunctionDeclSyntax())
        {
            true -> parseFunctionDecl(identifier, modifiers)
            else -> parseFunctionCallExpr(identifier)
        }
    }

    private fun isFunctionDeclSyntax(): Boolean
    {
        var i = 0
        while(true)
        {
            val token = peek(i)
            val next = peek(i + 1)
            if(token.type == Token.Type.S_CLOSE_PARENTHESIS && next.type != Token.Type.S_COLON)
            {
                return false
            }
            if(token.type == Token.Type.S_COLON)
            {
                return true
            }
            i++
        }
    }

    private fun parseFunctionDecl(identifier: Identifier, modifiers: List<Modifiers>? = null): FunctionFirstClassDecl
    {
        val params = parseFunctionParameters()
        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        expectThenAdvance(Token.Type.S_COLON)
        val returnType = parseType()
        var body: List<Statement>? = null
        when(underPointer.type)
        {
            Token.Type.S_OPEN_BRACE -> body = parseStatementBlock()
            else                    -> advancePointer()
        }
        return FunctionFirstClassDecl(identifier, returnType, params, body, modifiers ?: emptyList())
    }

    private fun parseFunctionCallExpr(identifier: Identifier): FunctionCallExpr
    {
        val parsedParameters = mutableListOf<Expr>()
        while(underPointer.type != Token.Type.S_CLOSE_PARENTHESIS && underPointer.type != Token.Type.S_EOF)
        {
            if(parsedParameters.isNotEmpty())
            {
                expectThenAdvance(Token.Type.S_COMMA)
            }
            parsedParameters.add(parseExpr())
        }
        expectThenAdvance(Token.Type.S_CLOSE_PARENTHESIS)
        return FunctionCallExpr(identifier, parsedParameters)
    }

    private fun parseIdentifierExpr(modifiers: List<Modifiers>? = null): Expr
    {
        return when(peek(1).type)
        {
            Token.Type.OP_ASSIGN                      -> parseAssignmentExpr()
            in Token.Type.compoundAssignmentOperators -> parseCompoundAssignmentExpr()
            Token.Type.S_COLON                        -> parseVariableDecl(modifiers)
            else                                      -> parseIdentifier()
        }
    }

    fun parseCompoundAssignmentExpr(): CompoundAssignmentExpr
    {
        val left = parseIdentifier() // todo: allow for more than just identifiers for now
        lateinit var op: BinaryOp
        expectAnyOfThenAdvance(Token.Type.compoundAssignmentOperators) {
            op = CompoundAssignmentExpr.findBinaryOp(underPointer.type)
            advancePointer()
        }
        val right = parseExpr()
        return CompoundAssignmentExpr(left, op, right)
    }

    fun parseAssignmentExpr(): AssignmentExpr
    {
        val identifier = parseIdentifier()
        expectThenAdvance(Token.Type.OP_ASSIGN)
        val value = parseBinaryExpr()
        return AssignmentExpr(identifier, value)
    }

    fun parseClassDecl(modifiers: List<Modifiers>? = null): ClassDecl
    {
        advancePointer() //consume the class keyword
        val className = parseType() // TODO: maybe for later type generification / templates ?? :D
        // todo: implement parsing for class inheritance
        expectThenAdvance(Token.Type.S_OPEN_BRACE)
        val members = mutableListOf<FirstClassDecl>()
        do
        {
            val memberModifiers = parseModifiers().also {
                it.all { modifier -> modifier.scope.contains(Modifiers.Scope.CLASS) }
            }
            members.add(
                when(peek(1).type != Token.Type.S_OPEN_PARENTHESIS)
                {
                    true -> parseVariableDecl(memberModifiers)
                    else ->
                    {
                        if(!isFunctionDeclSyntax())
                        {
                            Diagnostics.Logging.finer("Kira", "Under = $underPointer")
                            Diagnostics.panic(
                                "KiraParser::parseClassMemberExpr",
                                "Expected a function member here",
                                location = underPointer.canonicalLocation,
                                selectorLength = underPointer.content.length
                            )
                        }
                        parseFunctionCallOrDeclExpr(memberModifiers) as FunctionFirstClassDecl // if this throws, then it is 99.99% a bug
                    }
                }
            )
        } while(underPointer.type != Token.Type.S_CLOSE_BRACE && underPointer.type != Token.Type.S_EOF)
        expectOptionalThenAdvance(Token.Type.S_CLOSE_BRACE)
        return ClassDecl(className, modifiers ?: emptyList(), members)
    }

    fun parseVariableDecl(modifiers: List<Modifiers>? = null): VariableFirstClassDecl
    {
        val identifier = parseIdentifier()
        expectThenAdvance(Token.Type.S_COLON)
        val type = parseType()
        var value: Expr? = null
        if(underPointer.type == Token.Type.OP_ASSIGN)
        {
            advancePointer()
            value = parseBinaryExpr()
        }
        return VariableFirstClassDecl(identifier, type, value, modifiers ?: emptyList())
    }

    fun parseStringLiteral(): StringLiteral
    {
        val value = underPointer.content
        expectThenAdvance(Token.Type.L_STRING)
        return StringLiteral(value)
    }

    fun parseIntegerLiteral(): IntegerLiteral
    {
        var value by Delegates.notNull<Long>()
        try
        {
            value = underPointer.content.toLong()
        }
        catch(e: Exception)
        {
            Diagnostics.panic(
                "KiraParser::parseIntegerLiteral",
                "Unable to read '${underPointer.content}' as an integer literal",
                cause = e,
                location = underPointer.canonicalLocation,
                selectorLength = underPointer.content.length
            )
        }
        expectThenAdvance(Token.Type.L_INTEGER)
        return IntegerLiteral(value)
    }

    fun parseFloatLiteral(): FloatLiteral
    {
        var value by Delegates.notNull<Double>()
        try
        {
            value = underPointer.content.toDouble()
        }
        catch(e: Exception)
        {
            Diagnostics.panic(
                "KiraParser::parseIntegerLiteral",
                "Unable to read '${underPointer.content}' as an integer literal",
                cause = e,
                location = underPointer.canonicalLocation,
                selectorLength = underPointer.content.length
            )
        }
        expectThenAdvance(Token.Type.L_FLOAT)
        return FloatLiteral(value)
    }

    fun parseBoolLiteral(): BoolLiteral
    {
        var value by Delegates.notNull<Boolean>()
        try
        {
            value = underPointer.content.toBooleanStrict()
        }
        catch(e: Exception)
        {
            Diagnostics.panic(
                "KiraParser::parseBoolLiteral",
                "Unable to read ${underPointer.content} as a bool literal",
                cause = e,
                location = underPointer.canonicalLocation,
                selectorLength = underPointer.content.length
            )
        }
        expectAnyOfThenAdvance(arrayOf(Token.Type.L_TRUE_BOOL, Token.Type.L_FALSE_BOOL))
        return BoolLiteral(value)
    }

    fun parseIdentifier(): Identifier
    {
        val value = underPointer.content
        expectThenAdvance(Token.Type.IDENTIFIER)
        return Identifier(value)
    }

    fun parseType(): Type
    {
        val value = underPointer.content
        expectThenAdvance(Token.Type.IDENTIFIER)
        return Type(value)
    }

    fun parseModifiers(): List<Modifiers>
    {
        val modifiers = mutableListOf<Modifiers>()
        while(underPointer.type in Token.Type.modifiers)
        {
            val currentModifier = Modifiers.byTokenType(underPointer.type)
            if(currentModifier in modifiers)
            {
                Diagnostics.panic(
                    "KiraParser::parseModifiers",
                    "The modifier ${currentModifier.tokenType.diagnosticsName()} was already specified at ${underPointer.canonicalLocation}. Remove the duplicate modifier.",
                    location = underPointer.canonicalLocation,
                    selectorLength = underPointer.content.length
                )
            }
            modifiers.add(Modifiers.byTokenType(underPointer.type))
            advancePointer()
        }
        return modifiers
    }
}