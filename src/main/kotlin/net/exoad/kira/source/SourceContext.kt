package net.exoad.kira.source

import net.exoad.kira.Public
import net.exoad.kira.compiler.analysis.diagnostics.Diagnostics
import net.exoad.kira.compiler.analysis.diagnostics.isNotRepresentableDiagnosticsSymbol
import net.exoad.kira.compiler.frontend.lexer.Token
import net.exoad.kira.compiler.frontend.parser.ast.ASTNode
import net.exoad.kira.compiler.frontend.parser.ast.RootASTNode
import java.util.*

/**
 * a source context represents a single source file and contains all the processed information for that source file
 * this includes information like:
 *
 * 1. the raw preprocessed content (everything after [net.exoad.kira.compiler.frontend.preprocessor.KiraPreprocessor])
 * 2. the lexical tokens generated by [net.exoad.kira.compiler.frontend.lexer.KiraLexer]
 * 3. the [ast] generated by [net.exoad.kira.compiler.frontend.parser.KiraParser]
 */
class SourceContext(val content: String, val file: String, val tokens: List<Token>)
{
    private val lines: List<String> = content.lines()
    lateinit var ast: RootASTNode
    lateinit var astOrigins: IdentityHashMap<ASTNode, SourcePosition>

    fun getLines(): List<String>
    {
        return lines
    }

    fun with(content: String, tokens: List<Token>? = null): SourceContext
    {
        return SourceContext(content, file, tokens ?: this.tokens)
    }

    fun relativeOriginOf(node: ASTNode): SourcePosition
    {
        if(!astOrigins.containsKey(node))
        {
            Diagnostics.panic("Kira", "Could not find a saved location for $node", context = this)
        }
        return astOrigins[node]!!
    }

    /**
     * 1-based indexing (is this lua? when anything refers to canonicity in my code, it often just means the way that ordinary folks (users of the language) would refer to things or like things
     */
    fun findCanonicalLine(lineNumber: Int): String
    {
        return lines[lineNumber - 1]
    }

    /**
     * Creates a visual pointer to a portion of [content] by the specified [sourcePosition] and how long of the content to point at [locatorLength]
     *
     * - [locatorLength] starts at the first character of [sourcePosition]'s [SourcePosition.column] parameter. *PS, this function will throw an assertion error if [locatorLength] is not `>=` (greater than or equal to) `1`*
     *
     * - commonly used by the [Diagnostics.panic] function to generate useful & friendly error messages
     */
    fun formCanonicalLocatorString(
        sourcePosition: SourcePosition,
        trailingText: String? = null,
        locatorLength: Int = 1,
    ): String
    {
        assert(locatorLength >= 1) { "Locator length must be visible!" }
        val line = findCanonicalLine(sourcePosition.lineNumber)
        return buildString {
            appendLine(
                "${
                    when(Public.Flags.useDiagnosticsUnicode)
                    {
                        true -> "⮞"
                        else -> "@"
                    }
                } [${file}] : $sourcePosition"
            )
            append(
                when
                {
                    sourcePosition.column < 0 || line.isNotRepresentableDiagnosticsSymbol() -> line
                    else                                                                    ->
                    {
                        val builder = StringBuilder()
                        val gutter = "${
                            when(Public.Flags.useDiagnosticsUnicode)
                            {
                                true -> "░"
                                else -> " "
                            }.repeat(sourcePosition.lineNumber.toString().length)
                        }| "
                        builder.appendLine(gutter)
                        builder.appendLine("${sourcePosition.lineNumber}| $line")
                        // makes sure the arrows are always aligned properly to the actual selected portion of the line
                        val gap = " ".repeat(sourcePosition.column - 1)
                        builder.append(gutter)
                        builder.append(gap)
                        builder.appendLine(
                            when
                            {
                                Public.Flags.useDiagnosticsUnicode -> "▲"
                                else                               -> "^"
                            }.repeat(locatorLength)
                        )
                        if(trailingText != null)
                        {
                            // allow for multi line and adjusts the gutter to allow for multi line support!
                            for(bit in trailingText.split("\n"))
                            {
                                builder.append(gutter)
                                builder.append(gap)
                                builder.append(bit)
                                builder.appendLine()
                            }
                        }
                        builder.toString()
                    }
                }
            )
        }
    }
}