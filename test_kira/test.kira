module "kira:main"
mut object Scope
{

}
//
//    // Test basic binary operators
//    mut result1: Int = 10 + 20 * 30 - 40 / 5
//    mut result2: Bool = true && false || !true
//    mut result3: Int = 15 % 7 ^ 3 & 0xFF | 0x0F
//
//    // Test comparison operators with complex expressions
//    mut comp1: Bool = (a + b) > (c - d) && (e * f) <= (g / h)
//    mut comp2: Bool = x >= y && z < w || m != n && p == q
//    // STRESS TEST: Multi-token angle bracket operators
//    // These are the challenging ones that need prediction
//
//    // Right shift operators
//    mut shift1: Int = value >> 2              // Simple right shift
//    mut shift2: Int = value >>> 3             // Unsigned right shift (3 tokens: > > >)
//    mut shift3: Int = complex_expr() >> (other_expr() + 1)
//    mut shift4: Int = nested_call(x, y) >>> calculate_shift_amount()
//
//    // Right shift assignment operators
//    mut assign1: Int = base_value
//    assign1 >>= 2                             // Right shift assignment (3 tokens: > > =)
//
//    mut assign2: Int = another_value
//    assign2 >>>= shift_amount()               // Unsigned right shift assignment (4 tokens: > > > =)
//
//    // These test operator precedence and associativity
//    mut complex1: Int = a >> b + c >>> d - e >>= f         // Multiple shift ops
//    mut complex2: Bool = (x > y) && (z >> 2) > (w >>> 1)  // Comparison of shifts
//    mut complex3: Int = func1() >> func2() >>> func3() + func4() >>= func5()
//
//    mut typeCheck1: Bool = obj is List<String>             // Type check (is keyword)
//    mut typeCheck2: Bool = value is Map<Int, String>       // Nested generic type check
//    mut typeCast1: String = obj as String                  // Type cast (as keyword)
//    mut typeCast2: List<Int> = collection as List<Int>     // Generic type cast
//
//    // EDGE CASES: Ambiguous angle bracket sequences
//    mut edge1: Bool = a > b > c                           // Chained comparisons
//    mut edge2: Int = x >> y >> z                          // Chained right shifts
//    mut edge3: Int = (a >> b) > (c >>> d)                 // Shift result comparison
//
//    // FUNCTION CALLS WITH COMPLEX OPERATORS
//    mut funcResult1: Int = calculate(a >> 2, b >>> 3, c >>= d)
//    mut funcResult2: Bool = compare(x > y, z >= w, m >> n > p >>> q)
//
//    // ASSIGNMENT OPERATORS STRESS TEST
//    mut assignTest: Int = 100
//    assignTest += 50        // Addition assignment
//    assignTest -= 25        // Subtraction assignment
//    assignTest *= 2         // Multiplication assignment
//    assignTest /= 4         // Division assignment
//    assignTest %= 7         // Modulo assignment
//    assignTest &= 0xFF      // Bitwise AND assignment
//    assignTest |= 0x0F      // Bitwise OR assignment
//    assignTest ^= 0xF0      // Bitwise XOR assignment
//    assignTest <<= 2        // Left shift assignment
//    assignTest >>= 1        // Right shift assignment
//    assignTest >>>= 1       // Unsigned right shift assignment (4 tokens!)
//
//    // RANGE OPERATORS
//    mut range1: Range = 1..10               // Simple range
//    mut range2: Range = start_val()..end_val()  // Function call range
//    mut range3: Range = (a + b)..(c * d)    // Expression range
//    mut range4: Range = list[0]..list[size - 1]  // Array access range
//
//    // MEMBER ACCESS WITH COMPLEX EXPRESSIONS
//    mut member1: String = obj.property.nested_property
//    mut member2: Int = array[index].field >> 2
//    mut member3: Bool = obj.method(x >> 1, y >>> 2) > threshold
//    mut member4: Float = chain.call1().call2() / other.value >>> shift_amount
//
//    // PARENTHESES AND PRECEDENCE TESTS
//    mut prec1: Int = (a + b) * (c - d) >> (e >>> f)
//    mut prec2: Bool = ((x > y) && (z < w)) || ((m >> n) > (p >>> q))
//    mut prec3: Int = func((a >> b) + (c >>> d), (e >>= f) * (g << h))
//
