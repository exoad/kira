module "test:kira"

fx helperCreateMap(): Map<Str, Int32> {
    return Map<Str, Int32> { }
}

pub class Point {
    require pub mut x: Int32
    require pub mut y: Int32

    pub fx dist(): Float64 {
        return (x * x + y * y) as Float64
    }
}

trait Printable {
    fx toStr(): Str
}

pub class Circle {
    require pub center: Point
    require pub mut radius: Int32

    pub fx area(): Float64 {
        return 3.14159 * (radius as Float64) * (radius as Float64)
    }
}

enum Color {
    RED = "red",
    GREEN = "green",
    BLUE = "blue"
}

fx compute(values: List<Int32>): Int32 {
    mut acc: Int32 = 0
    for mut i: 0..(values.size() - 1) {
        acc = acc + values[i]
    }
    return acc
}

fx main(): Void {
    mut nums: List<Int32> = [1, 2, 3, 4, 5]
    arr: Arr<Int32> = [ 10, 20, 30 ]
    total: Int32 = compute(nums)
    p: Point = Point { 3, 4 }
    c: Circle = Circle { p, 5 }
    col: Color = Color.RED
    if total % 2 == 0 {
        // total is even
    } else if total % 3 == 0 {
        // divisible by 3
    } else {
        // other
    }
    mut i: Int32 = 0
    while i < 3 {
        i = i + 1
    }
    do {
        // one-time
    } while false
    for mut k: 0..2 {
        // loop k
    }
    for mut idx: 0..(arr.size() - 1) {
        // access arr[idx]
    }
    fxSum: Int32 = (fx(a: Int32, b: Int32): Int32 { return a + b })(1, 2)
    try {
        throw "boom"
    } on e: Str {
        // caught exception
    }
}

pub class Box<T> {
    require pub value: T
}

pub class Container<K, V> {
    require pub mapping: Map<K, List<Arr<V>>>
}

pub class Deep {
    require pub data: Map<Map<Str, List<Arr<Int32>>>, Arr<Arr<Int32>>>
}

fx genericIdentity<T: Int32>(x: T): T {
    return x
}

fx nestedGenerics(): Map<Map<Map<Str, Str>, List<Int32>>, Arr<Arr<Int32>>> {
    return helperCreateMap()
}

complexVar: Map<Map<Str, List<Arr<Int32>>>, Arr<Arr<Int32>>> = helperCreateMap()

fx identity<T>(value: T): T {
    return value
}

fx swap<A, B>(first: A, second: B): Tuple2<B, A> {
    return Tuple2<B, A> { second, first }
}

fx makeBox<T>(value: T): Box<T> {
    return Box<T> { value }
}
